p,84

제1정규형: 모든 속성은 반드시 하나의 값을 가져야 한다.
ex) 연락처 속성에 [ 집 전화번호 ], [ 핸드폰 번호 ] 를 구별하기 어렵다.
그리고, A고객은 집전화 여러개, B 고객은 핸드폰이 여러대 라면 [ 원하는 속성 값 추출하기 어려움 ] 

해결방법 --> [ 고객 연락처 ]라는 엔티티를 추가하여 다중값에 대한 문제점을 해결

- 다중값을 제거 함으로써 [ 속성을 더 명확하게 활용 ]할 수 있다. 


P,88
제 2정규형 :  엔티티의 일반속성은 [ 주식별자 ] [ 전체에 종속적 ]이어야한다.

함수종속성 : 데이터들이 [ 어떤 기준값에 의해 ] 종속되는 현상

< 주문 상세 엔티티  > 
주문번호     상품번호           상품명 
110001      256             sql 전문가 가이드 
110002      257
110003      256             sql 전문가 가이드 
110004      256             sql 전문가 가이드 
110005      258

결정자 : 이때 기준 값을 말함  --> ex) 상품번호 
종속자 : 종속되는 값 --> ex) 상품명 

<< 아래는 함수적 종속성으로 표기시 모양 >> 
결정자 --> 종속자
상품번호 --> 상품명 

- 주문 상세 엔티티의 [ 상품명은 ] 식별자 전체가 아닌 [ 식별자 일부에만 종속적. ] --> 부분 종속적이라 한다.
--> [ 제 2 정규형을 위배 ]한 것이다. 


p,90

제 3정규형: 엔터티의 일반속성 간에는 [ 서로 종속적이지 않는다. ]

p,91

반정규화(역정규화) : 정규화를 반대로 하는것

정규화는 --> 데이터 중복을 최소화
반정규화는 -->성능을 위해 [ 데이터 중복을 허용 ]


p,96
제 2절 관계와 조인의 이해 

[ 관계를 맺는 것 ]은 부모의 식별자를 [ 자식에게 상속시키는 행위. ]
이때 부모의 식별자를 [ 자식의 식별자에 포함 ]하면 --> 식별관계
부모의 식별자를 [ 자식의 일반속성으로 상속 ]하면 --> 비식별관계

* 즉 [ 관계를 맺는다는 것 ] 식별자를 상속하고, 상속된 속성을 [ 매핑키로 활용 ]하여 [ 데이터를 결합해 볼 수 있다는 의미 ]
 
--> 이를 SQL에서는 조인(Join ) 이라 한다.


예) a.고객번호 = b.고객번호 <= 이 부분이 조인이고 고객번호가 바로 [ 조인키다. ]

​
p,98
○ 계층형 데이터 모델

- 계층형 모델이란 말 그대로 [ 계층 구조를 가진 데이터를 지칭 ]하는 것

계층형 구조에서는 셀프조인이 가능하다. 

셀프조인 -> 자기 자신과 관계를 맺음 -> 관계를 맺으면 [ 식별자를 상속 ]한다.

- 즉 emp 테이블에서 'SMITH' 의 관리자(상사)의 이름은 무엇인가를 질의해 보세요 .
select  b.ename
from emp a, emp b 
where a.ename ='SMITH'  
and a.mgr = b.empno ; 

따라서 한 테이블에서 [ 한 속성을 매핑키로 활용 ]해서 [ 다른 속성을 찾을 수 있다. ]

​
p,101
○ 상호배타적(Exclusive-OR) 관계

예) 주문 엔터티에는 개인 또는 법인번호 [ 둘 중 하나만 상속될 수 있음 ]을 의미. 
    즉 [ 주문은 ] 개인 또는 법인고객 중 [ 하나의 고객만 가능. ]

* 개인고객과 법인고객은 아무 공통점 없음

​

3. 모델이 표현하는 트랜잭션의 이해

​

○ 트랜잭션

데이터베이스의 논리적 연산단위

계좌이체 과정처럼 하나의 업무 단위로 묶여서 처리돼야 한다는 것. => 이러한 업무 단위가 트랜잭션

​

보통 IE 표기법, 바커 표기법으로 표기된 모델을 보면 

원이 붙지않거나 실선일 경우 필수적인 관계라는 의미이다 즉 예를 들어 주문과 주문상세는 함께 발생한다는 의미. 

태생적으로 동시발생이라면 당연히 하나의 트랜잭션으로 묶어 처리해야한다. (모델 표현만 보고도 트랜잭션 이해가능😏)

트랜잭션을 하나로 묶는다는 것은 커밋단위를 하나로 묶어야 함을 의미한다.

​

4. Null 속성의 이해

​

○ Null 값의 연산은 언제나 Null

Null 값은 '공백이나 숫자 0'이 아니다.

'아직 정의되지 않은 미지의 값', '현재 데이터를 입력 못하는 경우' 즉 값이 존재하지 않음을 의미

존재하지 않는 값에는 연산이 불가능하다 따라서 Null연산은 Null을 결과로 줄 수 밖에 없다.

​

○ 집계함수는 Null 값을 제외하고 처리한다

sum,avg이런건 모두 Null값을 제외하고 처리하게 된다. 

count함수(총건수)는 Null항목도 세니까 조심!

​

5.본질식별자 vs 인조식별자 

​

식별자는 대체 여부에 따라 본질식별자와 인조식별자로 분류된다. 

본질식별자 : 업무에 의해 만들어진 식별자

인조식별자 : 인위적으로 만든 식별자

​

인조식별자를 사용하는 방식에는 크게 두가지 문제점이 있다.

​

▷ 중복 데이터로 인한 품질 문제

예를 들어 주문상세번호가 식별자일때 동일한 insert문이 발생해면 기본키 제약은 문제가 없어서 처리가 되고만다.

따라서 최대한 DBMS에서 이러한 문제를 막아줄 수 있게 본질식별자를 지향해야 한다. 

​

▷ 불필요한 인덱스 생성 문제
[출처] SQLD공부🗿_데이터모델과 SQL|작성자 보석반지

